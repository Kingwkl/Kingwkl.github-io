

## 记面试问题

#### 1、一定要提前了解投递的岗位

#### 2、宏扩展

  这个我是真的没有听清楚，听成了“无扩展”，懵逼了半天，最后只能说我不太了解，下去查查看一下。下来搜了一下，发现讲起来还是比较好理解的，只要记住宏不是函数，它只是一个替换就好了。比如：

***

#define TEST(a,b) a*b

int a = TEST(1 + 2, 3);      //这里只是做了一个简单替换而已，千万不要算

​										//a = 1+2*3=7，而不是(1+2)\*3=9，不要擅作主张算出来！

***



#### 3、TCP和UDP的区别？分别有什么应用？

​	这个题我回答的不是很完美，只是讲了部分区别。

​	（1）连接性

​			TCP是面向连接的协议，UDP是面向无连接的协议；TCP用三次握手建立连接，UDP发送数据前不需要建立连接。

​	（2）可靠性

​			TCP可靠，UDP不可靠；TCP丢包会自动重传，UDP不会。

​	（3）有序性

​			TCP有序，UDP无序。消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。

​	（4）有界性

​			TCP无界，UDP有界；TCP通过字节流传输，UDP中每一个包都是单独的。

​	（5）拥塞控制

​			TCP有流量控制（拥塞控制），方式有滑动窗口以及慢开始、拥塞避免、快重传、快恢复，UDP没有拥塞控制。

​	（6）传输速度

​			TCP传输慢，UDP传输快；因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。所以视频流、广播电视、在线媒体游戏等选择使用UDP。

​	（7）量级

​			TCP是重量级，UDP是轻量级；TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。

​	（8）头部大小

​			TCP首部开销20字节，UDP的首部开销小，只有8字节。

​	（9）应用场合不同

​			TCP一般应用在对可靠性要求比较高的场合，例如：FTP、HTTP、SMTP、SSH、Telnet等。而UDP一般应用在对实时性比较高的场合，例如视频直播，大文件传输、流媒体、物联网等。

#### 4、指针和引用的区别

​	这个比较常见了，所以回答的还行。引用是个变量的别名，不能为空，必须在声明的时候进行初始化，而且之后不能修改为其他的变量的别名，其sizeof()的大小是所应用的变量(对象)的大小。而定义一个指针，编译器会为指针分配内存，指针可以不初始化，可以线声明后初始化，并且存在指向空值的指针，其sizeof()的大小为4字节(32机器)。

#### 5、对于一些运行频率高且简单的函数，C中如何实现？C++中如何实现？

​	对于一些高频简单的函数，在C语言中经常使用宏定义进行实现，而在C++中经常使用 inline (内联函数)进行实现，因为编译器在编译的时候就已经对函数进行了替换，提高了运行效率。

#### 6、C++和C有什么区别？

​	首先就是C是面向过程的，而C++是面向对象的。C++可重用性好，可移植，其运行效率高，高效安全，提供了标准库STL，很多优秀的程序框架包括Boost、Qt、MFC、OWL就是使用的C++。对于嵌入式类的项目使用C语言比较多一点，对于一些项目中使用 java 会比C++更加高效，但是对于一些大型项目，使用C++就会比 java 高效很多。

#### 7、static 在 C 和 C++ 中的区别

​    在C语言中，静态变量(不管全局还是局部)，都是先于main函数创建并分配内存；在C++中，静态变量是第一次使用的时候才创建并分配。（1）局部静态变量；（static自动赋初值0，而auto类型的初值是不确定的）（2）外部静态变量/函数；（作用域限制在本文件）**前两种C和C++都有，第三种仅在C++中有。**（3）静态数据成员/成员函数；C++重用了这个关键字，表示属于一个类而不是属于此类的任何特定对象的变量和函数。C++中，对于静态数据成员的初始化，普通数据成员在构造函数的函数体或初始化表中初始化，常量数据成员(const int a)必须在构造函数的初始化表中初始化，而静态数据成员(static int b)则必须在外类初始化(int 类名::b=100;)，这是因为静态数据成员不属于任何一个对象，而是属于整个类。静态数据成员存储在全局数据区，且必须初始化才可以使用，不能在类声明中初始化，如果不在类外赋值，则自动初始化为0；而对于静态成员函数，其也是属于整个类的，但是不属于任何一个对象。静态成员函数可以被该类的所有对象直接访问，静态成员函数只能访问静态成员，不可以访问非静态成员。

#### 8、C++vector对象是如何增长的

如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置——因为元素必须是连续存储的。容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。**只有当迫不得已的时候才可以分配新的内存空间**

***

#include<iostream>
#include<vector>
using namespace std;
int main()
{
    vector<int>a;
    a.reserve(6);																	//将capacity至少设定为6，可能更大
    cout<<"1、size:"<<a.size()<<endl;									//1、size=0
    cout<<"1、capacity:"<<a.capacity()<<endl;					  //1、capacity=6
    for(int i=1;i<=10;i++)
        a.push_back(i);															//存储空间不够，扩存，翻倍为12
    cout<<"2、size:"<<a.size()<<endl;									//2、size=10
    cout<<"2、capacity:"<<a.capacity()<<endl;					  //2、capacity=12
    while(a.size()!=a.capacity()){
        a.push_back(2);
    }
    cout<<"3、size:"<<a.size()<<endl;									//3、size=12
    cout<<"3、capacity:"<<a.capacity()<<endl;					  //3、capacity=12
    a.push_back(5);
    cout<<"4、size:"<<a.size()<<endl;									//4、size=13
    cout<<"4、capacity:"<<a.capacity()<<endl;					  //4、capacity=24
    return 0;
}

***

我们也可以调用***a.shrink_to_fit();***来要求归还当前剩余内存间，这个时候size没有改变，但capacity改变了。

#### 9、new/delete和malloc/free的区别

|                   | new/delete              | malloc/free                            |
| :---------------- | ----------------------- | -------------------------------------- |
| 分配的内存位置    | 自由存储区              | 堆                                     |
| 分配成功返回值    | 完整类型指针            | void *                                 |
| 分配失败的返回值  | 默认抛出异常(bac_alloc) | 返回NULL                               |
| 分配内存的大小    | 编译器自己计算          | 显示的指出                             |
| 内存的扩充        | 无法直接的处理          | 使用realloc简单完成                    |
| 函数的重载        | 允许                    | 不允许                                 |
| 构造函数/析构函数 | 调用                    | 不调用                                 |
| 处理数组          | 有处理数组的new[]       | 需要用户计算数组的大小然后进行内存分配 |

​	

​     





